#### 指针和引用的区别： ####
（引用类型必须和引用实体是同种类型的）  
1.引用在定义时必须初始化，指针没有要求。  
2.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。  
3.没有NULL引用，但有NULL指针。  
4.在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)  
5.引用自加即引用的实体增加1， 指针自加即指针向后偏移一个类型的大小。  
6.有多级指针，但是没有多级引用。  
7.访问实体方法不同，指针需要显示解引用，引用编译器自己处理。  
8.引用比指针使用起来相对安全。  

----------
#### 编译与链接 ####
程序翻译：  
1.预处理：宏替换、去注释、头文件展开、条件编译  
2.编译：(C->汇编)  
3.链接：(静态链接、动态链接)-> 可执行二进制  
 Linux默认动态链接，  
4.静态链接    -static   
-g debug   默认
-g release  
ESC  iso  

----------

#### 浮点数的存储 ####
十进制5.0  ，二进制 101.0 相当于 1.01x2^2   
=>  s = 0 (符号位) M = 1.01 (有效数字) E = 2 (指数)  
32位浮点数   
S（1）   E（8）  M（23）  
64位浮点数  
S（1）   E（11） M（52）  

#### malloc/free ####
void* malloc(size_t size);   
void free(void* ptr);  
calloc  
void* calloc(size_t num, size_t size);  
与malloc的区别只在于calloc会在返回地址之前把申请的空间的每个字节初始化为0    
realloc  
void* realloc(void* ptr, size_t size);  

----------
#### 封装 ####
封装：隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互，将数据和操作数据的方法进行有机结合 

----------
 
#### C语言和C++中struct的区别 ####
1.C++将struct当成类来处理，所以C++的struct可以包含C++类的所有东西，例如构造函数、析构函数、有元等，C++的struct和C++的类唯一不同的就是：  
struct成员默认的是public，class默认private。而C语言struct不是类，不可以有函数，也不能使用类的特征例如：public等关键字，也不可以有static关键字。  
2.C++ struct里面成员初始化的形式和类是相同的，不可以直接初始化，就是不可以定义成员的时候同时初始化。C语言struct中间的某个类型(例如：int)也不可以直接初始化.   
3.初始化方式，C++ struct的初始化，C++不仅拥有C语言的初始化方式，也可以使用类的初始化方式。  
4.类型不同   
struct HE  
{  
  int a;   
};   
在C里面实际上数据类型为（struct HE），所以定义一个结构体HE变量都要带上struct。而在C++里面实际上数据类型为HE（主要因为结构体被当成类对待了），所以定义变量不需要struct  4

----------
#### c语言中为什么不能支持函数重载 ####
编译后函数名变化只是在原来的函数名前加了一个下划线，所以当同名的函数参数不同时，编译器无法解析到他们的不同，因为它们编译后的名称都相同，所以C语言不能函数重载。  

----------

#### 宏的优缺点 ####
优点：  
1.增强代码的复用性。  
2.提高性能   
缺点：   
1.不方便调试宏。(因为预编译阶段进行了替换）  
2.导致代码可读性差，可维护性差，容易误用。  
3.没有类型安全的检查   

----------

#### C++有哪些技术可以替代宏 ####
1.常量定义换用const  
2.函数定义换用内联函数   
3.类型重定义换用typedef  

----------
#### 类的实例化 ####
用类类型创建对象的过程，称为类的实例化  
1.类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它  
2.一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量  

----------
#### 结构体内存对其规则 ####
1.第一个成员在结构体偏移量为0的地址处   
2.其他成员变量要对齐到某一数字（对齐数）的整数倍的地址处  
 注意：对齐数=编译器默认的一个对齐数与该成员大小的较小值   
vs中默认的值为8，GCC中默认值为4  
3.结构体总大小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍  
4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。  
