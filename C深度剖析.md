#### 关键字 ####
**C99**中有32个关键字  
C语言中的auto关键字: 声明一个变量为自动变量，编译器在默认的缺省情况下，所有变量都是auto的  
C++中的auto关键字是一个类型说明符，通过变量的初始值或者表达式中参与运算的数据类型来推断变量的类型，C++中的auto变量必须初始化。  

**register**关键字：  
这个关键字要求编译器尽可能的将变量存放在CPU内部的寄存器中而不是通过内存寻址访问以提高效率。注意是**尽可能**，不是**绝对**。  

使用register注意点：  
register变量必须是能被CPU寄存器所接受的类型。意味着register变量必须是一个单个的值，并且其长度应小于或等于整型的长度。而且register变量可能不存放在内存中，所以不能用取地址运算符"**&**"来获取register变量的地址。  

**static**  
在C语言中主要有两个作用：  
1. 修饰变量  
变量又分为局部和全局变量，但它们都在内存的静态区。  
**静态全局变量**
作用域：**仅限于变量被定义的文件中**，其他文件即使使用extern声明也没法使用它。准确的说是从定义之处开始，到文件结尾处结束，在定义之处前面的那些代码行也不能使用它。想要使用得在前面加上extern ***。  
生命周期：整个程序运行期间都有效  

**静态局部变量**  
作用域：在函数体里面定义的，就只能在这个函数里面使用，同一个文档中的其他函数也用不了。  
生命周期：由于被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值还是不会被销毁，函数下次使用时仍然能用到这个值。  

2.修饰函数  
函数前面加static使得函数成为静态函数。但此处"static"的含义不是指存储方式，而是指对函数的作用域仅局限于本文件(所以又称为内部函数)。使用内部函数的好处是：不同的人编写不同的函数时，不用担心自己定义的函数，是否会与其他文件中的函数同名。  

C++中：  
1.修饰成员变量：**静态成员变量**   
2.修饰成员函数：**静态成员函数**


**基本数据类型**   
![](https://img-blog.csdn.net/2018091613193955?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW54aW42OTkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  

**sizeof**  
这是一个关键字，并不是函数  
int i = 0;  
A) sizeof(int);   √  
B) sizeof(i);     ×  
C) sizeof int;    ×  
D) sizeof i;      √    

sizeof在计算**变量**所占空间大小时，括号可以省略，而计算**类型**大小时不能省略。  

**switch**：  
case关键字后面的值**只能是整型或字符型或常量表达式**  

**void**  
void 的字面意思是"空类型"，void* 则为"空类型指针"，void*可以指向任何类型的数据。void几乎只有"注释"和限制程序的作用，因为void不能用来定义变量.  
void真正发挥作用在于：  
（1）对函数返回的限定;  
（2）对函数参数的限定;  

在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。  

无论是在C还是在C++中，若函数不接受任何参数，一定要指明参数为void。  

return语言不可以返回指向"栈内存"的"指针"，因为该内存在函数体结束时被自动销毁。  

define和const  
编译器通常不为普通const只读变量分配储存空间，而是将它们保存在**符号表**中，这使得它成为一个编译期间的值，没有了存储与读取内存的操作，使得它的效率也很高。  
例如：  
 #define M 3    
 const int N = 5;  // 此时并未将N放入内存中  
 ...  
 int i = N;   // 此时为N分配内存，以后不在分配！    
 int I = M;   // 预编译期间进行宏替换，分配内存  
 int j = N;   // 没有内存分配  
 int J = M;   // 再进行宏替换，又一次分配内存   
const定义的只读变量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是**立即数**，所以，const定义的只读变量在程序运行过程中只有一份拷贝(因为它是全局的只读变量，存放在静态区)，而#define定义的宏常量在内存中有若干个拷贝。#define宏是在预编译阶段进行替换，而const修饰的只读变量是在编译的时候确定其值。#define宏没有类型，而const修饰的只读变量具有特定的类型。  

**const**  
1.修饰一般变量  
一般变量是指简单类型的只读变量。这种只读变量在定义时，修饰符const可以用在类型说明符前，也可以用在类型说明符后。例如：   
int const i = 2;  或   const int i = 2;   
2.修饰数组  
定义或说明一个只读数组可采用如下格式：  
int const a[5] = {1, 2, 3, 4, 5}; 或  
const int a[5] = {1, 2, 3, 4, 5};  
3.修饰指针  
const int* p;   // p可变，p指向的对象不可变   
int const* p;   // p可变，指向的对象不可变   
int* const p;   // p不可变，p指向的对象可变  
const int* const p;  // 指针p和p指向的对象都不可变  

记忆方法： 忽略类型名(编译器解析的时候也是忽略类型名)，我们看const离哪个近。  
const `int`* p;  // const 修饰*p，p是指针，*p是指针指向的对象，不可变  
int const* p;  // const修饰*p,p是指针，*p是指针指向的对象，不可变   
int* const p;  // const修饰p,p不可变，p指向的对象可变  
const int* const p;  // 前一个const 修饰*p，后一个const修饰p，指针p和p指向的对象都不可变  
